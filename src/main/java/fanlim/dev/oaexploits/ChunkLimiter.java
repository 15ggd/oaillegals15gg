package fanlim.dev.oaexploits;

import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

public class ChunkLimiter implements Listener {

    private final JavaPlugin plugin;
    private final Map<Material, Integer> blockLimits = new HashMap<>();
    private String blockLimitExceededMessage;
    private final Logger logger;

    public ChunkLimiter(JavaPlugin plugin) {
        this.plugin = plugin;
        this.logger = plugin.getLogger();
        loadConfig();
        Bukkit.getPluginManager().registerEvents(this, plugin);
    }

    public void loadConfig() {
        FileConfiguration config = plugin.getConfig();
        blockLimits.clear();
        Set<String> keys = config.getConfigurationSection("chunk-limiter.limits").getKeys(false);
        for (String key : keys) {
            try {
                Material material = Material.valueOf(key.toUpperCase());
                int limit = config.getInt("chunk-limiter.limits." + key);
                blockLimits.put(material, limit);
            } catch (IllegalArgumentException e) {
                logger.warning("Invalid block type in config: " + key);
            }
        }
        blockLimitExceededMessage = config.getString("chunk-limiter.messages.block-limit-exceeded", "You cannot place more than {limit} {block} blocks in this chunk.");
    }

    @EventHandler
    public void onBlockPlace(BlockPlaceEvent event) {
        Block block = event.getBlock();
        Material material = block.getType();
        Player player = event.getPlayer();

        if (blockLimits.containsKey(material)) {
            Chunk chunk = block.getChunk();
            int currentCount = countBlocksInChunk(chunk, material);
            int limit = blockLimits.get(material);

            if (currentCount >= limit) {
                event.setCancelled(true);
                player.sendMessage(formatMessage(blockLimitExceededMessage, limit, material));
                logger.info(player.getName() + " attempted to place " + material + " exceeding the limit in chunk " + chunk.toString());
            }
        }
    }

    private int countBlocksInChunk(Chunk chunk, Material material) {
        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < chunk.getWorld().getMaxHeight(); y++) {
                for (int z = 0; z < 16; z++) {
                    Block block = chunk.getBlock(x, y, z);
                    if (block.getType() == material) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    private String formatMessage(String message, int limit, Material material) {
        return message.replace("{limit}", String.valueOf(limit))
                .replace("{block}", material.toString());
    }

    public void reloadChunkLimiterConfig() {
        plugin.reloadConfig();
        loadConfig();
        logger.info("ChunkLimiter configuration reloaded.");
    }
}
