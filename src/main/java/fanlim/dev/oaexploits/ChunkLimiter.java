package fanlim.dev.oaexploits;

import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

public class ChunkLimiter implements Listener {

    private final JavaPlugin plugin;
    private final Map<Material, Integer> blockLimits = new HashMap<>();
    private final Map<Chunk, Map<Material, Integer>> chunkBlockCounts = new HashMap<>();
    private String blockLimitExceededMessage;
    private final Logger logger;

    public ChunkLimiter(JavaPlugin plugin) {
        this.plugin = plugin;
        this.logger = plugin.getLogger();
        loadConfig();
        Bukkit.getPluginManager().registerEvents(this, plugin);
    }

    // Loads configuration from the config file
    private void loadConfig() {
        FileConfiguration config = plugin.getConfig();
        blockLimits.clear();
        chunkBlockCounts.clear();

        // Load block limits from config
        Set<String> keys = config.getConfigurationSection("chunk-limiter.limits").getKeys(false);
        for (String key : keys) {
            try {
                Material material = Material.valueOf(key.toUpperCase());
                int limit = config.getInt("chunk-limiter.limits." + key);
                blockLimits.put(material, limit);
            } catch (IllegalArgumentException e) {
                logger.warning("Invalid block type in config: " + key);
            }
        }

        // Load limit exceeded message from config
        blockLimitExceededMessage = config.getString("chunk-limiter.messages.block-limit-exceeded",
                "You cannot place more than {limit} {block} blocks in this chunk.");
    }

    @EventHandler
    public void onBlockPlace(BlockPlaceEvent event) {
        Block block = event.getBlock();
        Material material = block.getType();
        Player player = event.getPlayer();
        Chunk chunk = block.getChunk();

        if (blockLimits.containsKey(material)) {
            int limit = blockLimits.get(material);
            int currentCount = getBlockCountInChunk(chunk, material);

            if (currentCount >= limit) {
                event.setCancelled(true);
                player.sendMessage(formatMessage(blockLimitExceededMessage, limit, material));
                logger.info(String.format("%s attempted to place %s exceeding the limit in chunk %s",
                        player.getName(), material, chunk.toString()));
            } else {
                incrementBlockCount(chunk, material);
            }
        }
    }

    @EventHandler
    public void onBlockBreak(BlockBreakEvent event) {
        Block block = event.getBlock();
        Material material = block.getType();
        Chunk chunk = block.getChunk();

        if (blockLimits.containsKey(material)) {
            decrementBlockCount(chunk, material);
        }
    }

    // Returns the count of specific blocks in a chunk, recalculates if not cached
    private int getBlockCountInChunk(Chunk chunk, Material material) {
        if (!chunkBlockCounts.containsKey(chunk)) {
            chunkBlockCounts.put(chunk, new HashMap<>());
        }

        Map<Material, Integer> materialCounts = chunkBlockCounts.get(chunk);
        if (!materialCounts.containsKey(material)) {
            materialCounts.put(material, countBlocksInChunk(chunk, material));
        }

        return materialCounts.get(material);
    }

    // Increments the block count for a specific material in a chunk
    private void incrementBlockCount(Chunk chunk, Material material) {
        chunkBlockCounts.get(chunk).merge(material, 1, Integer::sum);
    }

    // Decrements the block count for a specific material in a chunk
    private void decrementBlockCount(Chunk chunk, Material material) {
        chunkBlockCounts.get(chunk).merge(material, -1, Integer::sum);
    }

    // Counts the number of blocks of a specific material in a given chunk
    private int countBlocksInChunk(Chunk chunk, Material material) {
        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < chunk.getWorld().getMaxHeight(); y++) {
                for (int z = 0; z < 16; z++) {
                    Block block = chunk.getBlock(x, y, z);
                    if (block.getType() == material) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    // Formats the limit exceeded message
    private String formatMessage(String message, int limit, Material material) {
        return message.replace("{limit}", String.valueOf(limit))
                .replace("{block}", material.toString());
    }

    // Reloads the configuration for the ChunkLimiter
    public void reloadChunkLimiterConfig() {
        plugin.reloadConfig();
        loadConfig();
        logger.info("ChunkLimiter configuration reloaded.");
    }
}