package fanlim.dev.oaexploits.antiexploits;

import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.yaml.snakeyaml.Yaml;

import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

public class EnchantedItems {

    private static final Logger LOGGER = Logger.getLogger(EnchantedItems.class.getName());
    private final Map<Enchantment, Integer> customMaxLevels = new HashMap<>();
    private final Map<ItemStack, Map<Enchantment, Integer>> originalEnchantments = new HashMap<>();
    private boolean removeInvalidEnchantments = true;
    private boolean allowEnchantmentRemovalOnBlocks = false;

    public EnchantedItems() {
        loadMaxEnchantmentLevels();
    }

    private void loadMaxEnchantmentLevels() {
        try (InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("maxEnchantment.yml")) {
            if (inputStream == null) {
                LOGGER.log(Level.SEVERE, "maxEnchantment.yml not found in resources.");
                return;
            }
            Yaml yaml = new Yaml();
            Map<String, Object> yamlData = yaml.load(inputStream);

            Map<String, Integer> enchantments = (Map<String, Integer>) yamlData.get("enchantments");
            for (Map.Entry<String, Integer> entry : enchantments.entrySet()) {
                Enchantment enchantment = Enchantment.getByName(entry.getKey());
                if (enchantment != null) {
                    customMaxLevels.put(enchantment, entry.getValue());
                } else {
                    LOGGER.log(Level.WARNING, "Enchantment " + entry.getKey() + " not found.");
                }
            }

            allowEnchantmentRemovalOnBlocks = (boolean) yamlData.getOrDefault("allowEnchantmentRemovalOnBlocks", false);

        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error loading max enchantment levels", e);
        }
    }

    public void setRemoveInvalidEnchantments(boolean remove) {
        this.removeInvalidEnchantments = remove;
    }

    public boolean hasOverleveledEnchantments(ItemStack item) {
        try {
            ItemMeta meta = item.getItemMeta();
            if (meta != null && meta.hasEnchants()) {
                for (Map.Entry<Enchantment, Integer> enchantment : meta.getEnchants().entrySet()) {
                    int maxLevel = customMaxLevels.getOrDefault(enchantment.getKey(), enchantment.getKey().getMaxLevel());
                    if (enchantment.getValue() > maxLevel || !enchantment.getKey().canEnchantItem(item)) {
                        LOGGER.log(Level.WARNING, "Item has overleveled or invalid enchantment: " + enchantment.getKey().getName() +
                                " Level: " + enchantment.getValue() + " Max Level: " + maxLevel);
                        return true;
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error checking enchantments", e);
        }
        return false;
    }

    public void removeOverleveledEnchantments(ItemStack item) {
        try {
            ItemMeta meta = item.getItemMeta();
            if (meta != null && meta.hasEnchants()) {
                boolean modified = false;
                Map<Enchantment, Integer> originalEnchants = new HashMap<>(meta.getEnchants());
                originalEnchantments.put(item, originalEnchants);

                for (Map.Entry<Enchantment, Integer> enchantment : originalEnchants.entrySet()) {
                    int maxLevel = customMaxLevels.getOrDefault(enchantment.getKey(), enchantment.getKey().getMaxLevel());
                    boolean canEnchantItem = enchantment.getKey().canEnchantItem(item);
                    if (enchantment.getValue() > maxLevel || (!canEnchantItem && !allowEnchantmentRemovalOnBlocks)) {
                        meta.removeEnchant(enchantment.getKey());
                        if (enchantment.getValue() > maxLevel) {
                            meta.addEnchant(enchantment.getKey(), maxLevel, true);
                        }
                        modified = true;
                        LOGGER.log(Level.INFO, "Removed or adjusted enchantment: " + enchantment.getKey().getName() +
                                " Level: " + enchantment.getValue() + " New Level: " + (enchantment.getValue() > maxLevel ? maxLevel : 0));
                    }
                }

                if (modified) {
                    item.setItemMeta(meta);
                    LOGGER.log(Level.INFO, "Overleveled or inappropriate enchantments removed and set to max levels or removed entirely.");
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error removing overleveled enchantments", e);
        }
    }

    public void rollbackEnchantments(ItemStack item) {
        try {
            if (originalEnchantments.containsKey(item)) {
                ItemMeta meta = item.getItemMeta();
                if (meta != null) {
                    meta.getEnchants().clear();
                    Map<Enchantment, Integer> originalEnchants = originalEnchantments.get(item);
                    for (Map.Entry<Enchantment, Integer> enchantment : originalEnchants.entrySet()) {
                        meta.addEnchant(enchantment.getKey(), enchantment.getValue(), true);
                    }
                    item.setItemMeta(meta);
                    originalEnchantments.remove(item);
                    LOGGER.log(Level.INFO, "Enchantments rolled back to original values.");
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error rolling back enchantments", e);
        }
    }

    public Map<Enchantment, Integer> getCustomMaxLevels() {
        return new HashMap<>(customMaxLevels);
    }

    public void setCustomMaxLevel(Enchantment enchantment, int level) {
        if (level > 0) {
            customMaxLevels.put(enchantment, level);
        } else {
            customMaxLevels.remove(enchantment);
        }
    }

    public interface CustomEnchantmentValidator {
        boolean isValid(Enchantment enchantment, int level, ItemStack item);
    }
}
