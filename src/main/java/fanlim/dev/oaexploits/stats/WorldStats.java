package fanlim.dev.oaexploits.stats;

import fanlim.dev.oaexploits.Oaexploits;
import net.md_5.bungee.api.ChatColor;
import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

public class WorldStats implements CommandExecutor, Listener {

    private final Oaexploits plugin;
    private final ExecutorService executorService;
    private int newChunksLoaded;

    public WorldStats(Oaexploits plugin) {
        this.plugin = plugin;
        this.executorService = Executors.newCachedThreadPool();
        this.newChunksLoaded = 0;
        Bukkit.getPluginManager().registerEvents(this, plugin);
    }

    @EventHandler
    public void onChunkLoad(ChunkLoadEvent event) {
        if (event.isNewChunk()) {
            newChunksLoaded++;
        }
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!command.getName().equalsIgnoreCase("worldstats")) {
            return false;
        }

        if (sender instanceof Player) {
            Player player = (Player) sender;
            String fetchingMessage = getWorldStatsConfig().getString("messages.fetching", "&bFetching world stats...");
            player.sendMessage(ChatColor.translateAlternateColorCodes('&', fetchingMessage));
        }

        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> displayWorldStats(sender));

        return true;
    }

    private void displayWorldStats(CommandSender sender) {
        int playersJoined = Bukkit.getOfflinePlayers().length;

        CompletableFuture<Long> worldSizeFuture = calculateFolderSize("world");
        CompletableFuture<Long> netherSizeFuture = calculateFolderSize("world_nether");
        CompletableFuture<Long> endSizeFuture = calculateFolderSize("world_the_end");

        long worldSize = getFutureResult(worldSizeFuture);
        long netherSize = getFutureResult(netherSizeFuture);
        long endSize = getFutureResult(endSizeFuture);

        String serverStartDate = getServerStartDate(Bukkit.getWorld("world"));

        String message = buildStatsMessage(playersJoined, worldSize, netherSize, endSize, serverStartDate, newChunksLoaded);

        if (sender instanceof Player) {
            Player player = (Player) sender;
            player.sendMessage(message);
        } else {
            sender.sendMessage(ChatColor.stripColor(message));
        }
    }

    private CompletableFuture<Long> calculateFolderSize(String worldName) {
        return CompletableFuture.supplyAsync(() -> getFolderSize(Paths.get(Bukkit.getWorldContainer().getAbsolutePath(), worldName)), executorService);
    }

    private long getFutureResult(CompletableFuture<Long> future) {
        try {
            return future.get();
        } catch (InterruptedException | ExecutionException e) {
            plugin.getLogger().severe("Error calculating folder size: " + e.getMessage());
            return 0;
        }
    }

    private long getFolderSize(Path folder) {
        AtomicLong size = new AtomicLong(0);
        try (Stream<Path> files = Files.walk(folder).parallel()) {
            files.filter(p -> p.toFile().isFile())
                    .forEach(p -> size.addAndGet(p.toFile().length()));
        } catch (IOException e) {
            plugin.getLogger().severe("Error reading folder size: " + e.getMessage());
        }
        return size.get();
    }

    private String formatSize(long size) {
        if (size >= 1024L * 1024L * 1024L * 1024L) {
            return String.format("%.2f TB", size / (1024.0 * 1024.0 * 1024.0 * 1024.0));
        } else if (size >= 1024L * 1024L * 1024L) {
            return String.format("%.2f GB", size / (1024.0 * 1024.0 * 1024.0));
        } else if (size >= 1024L * 1024L) {
            return String.format("%.2f MB", size / (1024.0 * 1024.0));
        } else if (size >= 1024) {
            return String.format("%.2f KB", size / 1024.0);
        } else {
            return size + " B";
        }
    }

    private String getServerStartDate(World world) {
        FileConfiguration config = getWorldStatsConfig();
        String configuredDate = config.getString("server-opening-date", null);

        if (configuredDate != null && !configuredDate.isEmpty()) {
            return ChatColor.translateAlternateColorCodes('&', configuredDate);
        }

        try {
            Path worldPath = world.getWorldFolder().toPath();
            BasicFileAttributes attr = Files.readAttributes(worldPath, BasicFileAttributes.class);
            LocalDate creationDate = attr.creationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMMM dd, yyyy");
            return creationDate.format(formatter);
        } catch (IOException e) {
            plugin.getLogger().severe("Error getting server start date: " + e.getMessage());
            return "Unknown";
        }
    }

    private String buildStatsMessage(int playersJoined, long worldSize, long netherSize, long endSize, String serverStartDate, int newChunksLoaded) {
        String header = getWorldStatsConfig().getString("messages.header", "&8&m----------------&6&lOpenAnarchy&8&m----------------");
        String footer = getWorldStatsConfig().getString("messages.footer", "&8&m----------------------------------------");
        String playersJoinedMessage = getWorldStatsConfig().getString("messages.players-joined", "&6&lPlayer Stats\n&7- &e{players_joined} &7player(s) have spawned at least once in the world.")
                .replace("{players_joined}", String.valueOf(playersJoined));
        String worldSizeMessage = getWorldStatsConfig().getString("messages.world-size", "&6&lWorld Size\n&7- The world has a file size of &e{world_size}.")
                .replace("{world_size}", formatSize(worldSize));
        String netherSizeMessage = getWorldStatsConfig().getString("messages.nether-size", "&6&lNether Size\n&7- The Nether has a file size of &e{nether_size}.")
                .replace("{nether_size}", formatSize(netherSize));
        String endSizeMessage = getWorldStatsConfig().getString("messages.end-size", "&6&lEnd Size\n&7- The End has a file size of &e{end_size}.")
                .replace("{end_size}", formatSize(endSize));
        String serverStartDateMessage = getWorldStatsConfig().getString("messages.server-start-date", "&6&lServer Start Date\n&7- The server was opened on &e{server_start_date}.")
                .replace("{server_start_date}", serverStartDate);
        String newChunksLoadedMessage = "&6&lNew Chunks Loaded\n&7- &e" + newChunksLoaded + " &7new chunks have been loaded since the server started.";

        return ChatColor.translateAlternateColorCodes('&',
                header + "\n" +
                        playersJoinedMessage + "\n" +
                        worldSizeMessage + "\n" +
                        netherSizeMessage + "\n" +
                        endSizeMessage + "\n" +
                        serverStartDateMessage + "\n" +
                        newChunksLoadedMessage + "\n" + // Added new chunks loaded message
                        footer);
    }

    private FileConfiguration getWorldStatsConfig() {
        return plugin.getWorldStatsConfig();
    }
}
